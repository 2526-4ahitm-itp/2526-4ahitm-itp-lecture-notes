= 25/26 - 4ahitm - itp - Lecture Notes
Thomas Stütz
1.0.0, {docdate}: Lecture Notes for Courses at HTL Leonding
:icons: font
:experimental:
:sectnums:
:source-highlighter: rouge
:docinfo: shared
ifndef::imagesdir[:imagesdir: images]
:toc:
ifdef::backend-html5[]
// https://fontawesome.com/v4.7.0/icons/
icon:file-text-o[link=https://github.com/2526-4ahitm-itp/2526-4ahitm-itp-lecture-notes/main/asciidocs/{docname}.adoc] ‏ ‏ ‎
icon:github-square[link=https://github.com/2526-4ahitm-itp/2526-4ahitm-itp-lecture-notes] ‏ ‏ ‎
icon:home[link=http://edufs.edu.htl-leonding.ac.at/~t.stuetz/hugo/2021/01/lecture-notes/]
endif::backend-html5[]

== Testtermine

* 1. Dez. 2025
* es wurden statt dem 2. Test schriftliche und mündliche Mitarbeitsüberprüfungen vereinbart

== 2025-09-15

=== Projekte

* Franklyn weiterarbeiten

* ev. Seniorenheim


==== Themen

* Gesundheit
* Umwelt
* Bildung
* Beeinträchtigte Personen



== 2025-09-16

=== Authentifizierung und Autorisierung

* Statuscodes sind nicht korrekt

** *401 Unauthorized* sollte *unauthenticated* heissen

** *403 Forbidden* sollte *unauthorized* heissen


==== Ablauf einer HTTP Anfrage

. Zugriff auf eine geschützte Ressource durch Request.

. Server antwortet mit *401 Unauthorized* und fordert Authentifizierung an. Der Client wird an den Keycloak weitergeleitet.

. Client authentifiziert sich beim Keycloak (z.B. durch Login).

. Keycloak sendet ein Token (z.B. JWT) an den Client zurück.

. Client sendet das Token in der nächsten Anfrage an den Server.

. Server überprüft das Token und gewährt Zugriff auf die Ressource, wenn das Token gültig ist.

==== Keycloak

===== Realm

===== User

===== Client

===== Role

* Collection von Rechten

===== Group

* Collection von Usern


== 2025-09-22

=== Projektideen Stütz

* Franklyn: Lehreraccounts, KI-Detektion, ev. weitere Funktionen wie aufzeigen
** Clemens, Jakob, Eldin, Gregor
* LeoIoT Jonas, Daniel L, Paul, Elias, Stefan
** Sensoren in Klassen mit Dashboard
** Dashboard für PV-Anlage und Verbräuche der Schule
* Trainingsplaner (Paul, Elias, Daniel L.)
* HTL 3D für Elternsprechtag
* MusicVoting
** Miriam, Simone, Marlies
* Der sprechende Eisbär (Chatbot mit KI)
* Dashboard mit Grafana und InfluxDB für eine Mineralölfirma
** Hanan
** Almin
* FPV-Drohnen Assistent (David, Simon)


=== Projektideen Schüler

* https://hackaday.io/project/191181-electromechanical-refreshable-braille-module/details[Brailleleiste]
* Lernplattform (Hanan) vgl. Code Academy
* HÜ-Planer (Clemens, Jakob)
* Whatsapp-Alternative (Miriam)
* SOS-Taschenrechner (Daniel R.)

=== Aufgabenstellung

* Erstellung einer Projektidee mit Projektkonzept
** User Stories
** Systemarchtitektur



== 2025-09-23 Keycloak

IAM ... Identity and Access Management

Keycloak ist ein Softwareprodukt zur Verwaltung von Identitäten und Zugriffsrechten in Anwendungen und Diensten. Es bietet Funktionen wie Single Sign-On (SSO), Benutzerverwaltung, Rollen- und Berechtigungsmanagement sowie Integration mit verschiedenen Authentifizierungsprotokollen wie OAuth2, OpenID Connect und SAML.



image::reverse-proxy-webpack.png[]


https://www.urldecoder.org/



Die Payload eines tokens ist nicht verschlüsselt jedoch fälschungssicher signiert.




* Was ist Keycloak
** Keycloak ist eine Open-Source Identity- und Access-Management-Lösung (IAM), die Single Sign-On (SSO) für Anwendungen und Services bereitstellt. Es übernimmt zentrale Aufgaben im Bereich der Authentifizierung und Autorisierung, basierend auf modernen Sicherheitsstandards wie OAuth 2.0, OpenID Connect (OIDC) und SAML 2.0.

https://2425-5bhif-wmc.github.io/03-tutorials-sxidn/[Keycloak Authenctication Flows]

https://2425-5bhif-wmc.github.io/03-tutorials-icqun/[Securing Quarkus Backends with Keycloak]



* CORS (Cross-Origin-Ressource-Sharing)
** CORS (Cross-Origin Resource Sharing) ist ein Sicherheitsmechanismus in Webbrowsern, der den Zugriff von Webanwendungen auf Ressourcen über Domänengrenzen hinweg regelt.

image::cors.png[]

* Was ist Kubernetes?
** Kubernetes ist ein Container-Orchestrierungstool, welches dafür sorgt , dass Container automatisch gestartet, überwacht, skaliert und im Fehlerfall neu gestartet werden.

== 2025-10-07

=== Pure Web

----
 npm create vite
----

* Wir verwenden Vite als Build-Tool (Bundler)
** https://vitejs.dev/guide/
** Erstellt ein großes javascript file mit allen Abhängigkeiten.
** Unterstützt auch React, Vue, Svelte, ...
** Einfacher zu konfigurieren als Webpack
** Vergleichbar mit `webpack`

* package-lock.json zu .gitignore hinzufügen


* Model erstellen


==== Proxy einrichten


https://vite.dev/config/server-options.html#server-proxy

https://vite.dev/config/server-options


==== Warum Typescript Module?

* Auf einer herkömmlichen Website wird alles javascript direkt im globalen Scope ausgeführt. Eigener Code im globalen Scope kann leicht mit fremdem Code kollidieren (z.B. Bibliotheken) und ist daher unwartbar.

* Deshalb werden Typescript Module verwendet. Diese haben ihren eigenen Scope und kollidieren nicht mit anderem Code.

image::typemodule.png[]

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules



==== Model

* Das Model ist die Wahrheit, die reine Wahrheit und nichts als die Wahrhei -> Single Source of truth

* Das Aussehen des Bildschirms wird *AUSSCHLIESSLICH* durch das Model bestimmt. In der GUI werden keine Zustände gespeichert.

== 2025-10-21

=== Trennung von Layout und Daten

==== MVC

==== MVVM


IMPORTANT: Ein Model ist immer notwendig. Ein Model ist die Wahrheit, die reine Wahrheit und nichts als die Wahrheit.


* Problem: Wir sollten die Daten nicht in den Komponenten speichern.

* Abhilfe: Die Daten sollten zentral gespeichert werden -> store



== 2025-11-04

image::tests-in-projekten.png[]




== 2025-11-10

=== Backlog mit User Stories

Jede Gruppe muss ein Backlog erstellen, in dem alle User Stories für das Projekt gesammelt werden. Dabei ist zu beachten, dass die User Stories klein genug sind, um in einem Sprint umgesetzt werden zu können. Auch sind nur wenige User Stories detailliert auszuarbeiten, die meisten sollten nur grob beschrieben werden, da diese erst späte im Projekt detailliert werden.

https://docs.github.com/de/issues

=== Systemarchitektur

Abgeleitet vom Backlog ist ein erster entwurf der Systemarchitektur zu erstellen. Dabei sind die wichtigsten Komponenten des Systems zu identifizieren und deren Zusammenspiel zu beschreiben. Auch sind die wichtigsten Technologien und Frameworks zu benennen, die im Projekt verwendet werden sollen.


== 2025-12-22

=== Teststrategien

* Vorgehen zum Auswählen von Testfällen

* Äquivalenzklassen
* Grenzwertanalyse


image::testen-einer-methode.png[]

image::testen-aequivalenzklassenmethode.png[]

image::testen-grenzwertanalyse.png[]


Testobjekte:
* Black-Box-Tests
* White-Box-Tests
* Gray-Box-Tests


==== Testaufbau

* Arrange - Act- Assert (AAA-Pattern)
* Given - When - Then (GWT-Pattern)


* Mock
** Mocking bedeutet täuschen oder vortäuschen
** Ein Mock-Objekt ist ein Objekt, das das Verhalten eines echten Objekts simuliert.
** Mocks werden verwendet, um Abhängigkeiten zu isolieren und kontrollierte Testumgebungen zu schaffen.
** Bibliotheken: Mockito, JMock, EasyMock

** Mock Objekte können auch Stubs oder Spies sein.
*** Ein Stub ist ein einfaches Mock-Objekt, das vordefinierte Antworten auf Methodenaufrufe zurückgibt.
*** Ein Spy ist ein Mock-Objekt, das das Verhalten eines echten Objekts überwacht und aufzeichnet.

* https://phauer.com/2019/modern-best-practices-testing-java/[Philipp Hauer's Blog - Modern Best Practices for Testing in Java^]

image::testebenen.png[]

== 2026-01-12

=== Testen des Backends

* Unit-Tests (assertj-core)
* Integrationstests (assertj-db)

siehe im Ordner `labs` das Projekt `testen`.

== 2026-01-20

=== API Testing mit httpyac

Um API-Endpunkte automatisiert und reproduzierbar zu testen, verwenden wir das Tool `httpyac`.

==== Installation und Setup
Die Installation erfolgt lokal im Projektverzeichnis (Ordner `api`), um globale Abhängigkeiten zu vermeiden.

[source,bash]
----
# Initialisierung des API-Ordners
cd api
npm init -y

# Lokale Installation von httpyac
npm install httpyac
----

==== Erstellen von Requests
Requests werden in einer `.http` Datei definiert. Mit `??` werden Test-Assertions direkt unter dem Request eingefügt.

[source,http]
----
# @name clients
GET http://localhost:8080/clients
?? status == 200
----

==== Automatisierung (package.json)
Um die Tests einfach über die CLI zu starten, wird ein Script in der `package.json` hinterlegt:

[source,json]
----
"scripts": {
  "test": "httpyac --send --all --bail request.http"
}
----

Der Aufruf erfolgt dann mittels:
[source,bash]
----
npm test
----

==== Konfiguration mit Variablen
Für unterschiedliche Umgebungen wird eine `http-client.config.js` erstellt. In der `request.http` kann dann die Variable `{{host}}` statt `localhost:8080` verwendet werden.

=== Code Coverage mit JaCoCo

JaCoCo (Java Code Coverage) misst, wie viel Prozent des Codes durch Tests tatsächlich ausgeführt werden.

==== Konfiguration Quarkus
Die Integration erfolgt über die `pom.xml` und die `application.properties`.

[source,xml]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-jacoco</artifactId>
  <scope>test</scope>
</dependency>
----

In den `application.properties` muss das Paket-Format umgestellt werden, um auch Integration-Tests korrekt zu erfassen:
[source,properties]
----
quarkus.package.type=uber-jar
----

==== Ausführung
Die Reports werden beim Build-Prozess generiert:

[source,bash]
----
mvn package
# Starten mit JaCoCo Agent (falls Integrationstests manuell geprüft werden)
java -jar target/*-runner.jar
----

Der fertige Report ist als interaktive Webseite unter `target/jacoco-report/index.html` verfügbar.



=== Test-Strategie (Prof. Aberger)

* **Code Coverage Ziel:** Ein Abdeckungsgrad von ca. **80%** wird angestrebt.
* **Sinn des Testens:** Die Abdeckung ist der Hauptgrund für das Testing, um die Stabilität bei Refactorings zu gewährleisten.
* **Code Design:** Verwendung von Expressions (z.B. Switch-Expression mit `return`) statt Statements erhöht die Testbarkeit und Übersichtlichkeit.
** Unnötige Getter und Setter sollten vermieden werden (Datenklassen/Records), da diese die Coverage-Statistik verfälschen (Boilerplate-Code ohne Logik).

[source,java]
----
// Effizientes Design: Expression statt Statement
public String resolve(int code) {
    return switch (code) {
        case 200 -> "OK";
        default -> "Error";
    };
}
----

















